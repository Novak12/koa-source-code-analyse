# 代码示例
在引入koa并执行项目监听时，都会执行以下代码：
```javascript
const koa = require('koa');
const app=new koa();

app.use((ctx,next)=>{
    ctx.body='电影首页';
})
app.listen(3000);
```
在上面的代码中，koa做了三个主要动作：koa实例化，执行use方法和listen方法，似乎我们将着三个部分整清楚了，那么koa的整个运作机制是不是更加清晰了呢？koa色使用代码如此简洁，但是内部的逻辑肯定不会简单。<br/>
context:表示一次对话的上下文（包含HTTP请求和回复）。通过加工这个对象就可以控制返回给用户的内容。<br/>
在koa2中会大量使用ES6的语法。
# koa初始化--application.js
当new一个koa时，实际上是application.js新建了一个Application实例对象，首先看看Application的构造函数的内容：
```javascript
constructor() {
    super();

    this.proxy = false;
    this.middleware = [];
    this.subdomainOffset = 2;
    this.env = process.env.NODE_ENV || 'development';
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
    if (util.inspect.custom) {
      this[util.inspect.custom] = this.inspect;
    }
  }
```
在构造函数中，主要是对属性初始化，如proxy,中间件，环境变量，request,response等。proxy 属性值是 true 或者 false, 它的作用在于是否获取真正的客户端 ip 地址；middleware 属性是中间件数组, 用于存储中间件函数的；subdomainOffset 属性会改变获取 subdomain(子域名) 时返回数组的值,
比如 test.page.example.com 域名, 如果设置 subdomainOffset 为 2, 那么返回的数组值为 [“page”, “test”], 如果设置为 3, 那么返回数组值为 [“test”].
# use()
```javascript
use(fn) {
    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
    if (isGeneratorFunction(fn)) {
      deprecate('Support for generators will be removed in v3. ' +
                'See the documentation for examples of how to convert old middleware ' +
                'https://github.com/koajs/koa/blob/master/docs/migration.md');
      fn = convert(fn);
    }
    debug('use %s', fn._name || fn.name || '-');
    this.middleware.push(fn);
    return this;
  }
```
在分析use()的源码时，首先要搞懂一个概念-中间件（middleware），在这里先简单的将其理解为解耦具体业务和底层逻辑的组件。

